# 数据存储架构方案对比

> 创建时间: 2026-01-11
> 状态: ✅ **已实施 - 方案 C (纯云端模式)**
> 实施时间: 2026-01-11

## 实施结果

最终选择并实施了**方案 C (纯云端模式)**，主要改动包括：

### 已删除的文件
- `src/services/db/index.ts` - IndexedDB 服务
- `src/stores/syncStore.ts` - 同步状态管理
- `src/components/sync/ConflictModal/` - 冲突解决弹窗
- `src/App.tsx` - 原应用入口 (已重构)

### 新增的文件
- `src/router/index.tsx` - React Router v6 路由配置
- `src/pages/LandingPage/` - Landing Page (产品介绍 + 登录)
- `src/pages/MainApp/` - 主应用 (需登录)
- `src/pages/AuthCallback/` - OAuth 回调处理
- `src/components/auth/AuthGuard/` - 路由认证守卫

### 路由结构
```
/                 → LandingPage (公开)
/app              → MainApp (需登录)
/share/:token     → ShareView (只读不需登录，可编辑需登录)
/auth/callback    → OAuth 回调
```

### 数据流
- 所有数据直接读写 Supabase，无本地存储
- 编辑后 500ms 防抖自动保存
- 登录后可跨设备访问

---

## 背景问题

当前架构采用 **本地优先 + 云端同步** 模式，存在以下问题：

1. **数据一致性差**: 本地 IndexedDB 和云端 Supabase 各有一份数据，同步逻辑复杂
2. **多端混乱**: 同一账户在不同浏览器/环境打开时，数据可能不同步
3. **冲突处理复杂**: 需要处理本地和云端数据冲突的场景
4. **代码复杂度高**: 需要维护两套存储逻辑和同步机制

## 方案概览

| 方案 | 核心思路 | 复杂度 | 一致性 | 离线支持 | 需登录 |
|------|----------|--------|--------|----------|--------|
| A. 当前方案 | 本地优先 + 云端同步 | 高 | 差 | 完全支持 | 否 |
| B. 混合模式 | 未登录用本地，登录后纯云端 | 中 | 好 | 仅未登录 | 否 |
| C. 纯云端 | 完全移除本地，强制登录 | 低 | 最佳 | 不支持 | 是 |
| D. 云端主存储 + 本地缓存 | 云端为主，本地仅缓存 | 中高 | 好 | 只读缓存 | 是 |

---

## 方案 A: 当前方案（本地优先 + 云端同步）

### 架构
```
┌─────────────────┐      ┌─────────────────┐
│   IndexedDB     │◄────►│    Supabase     │
│   (本地主存储)   │ 同步  │   (云端备份)     │
└─────────────────┘      └─────────────────┘
```

### 数据流
1. 所有操作先写入本地 IndexedDB
2. 登录后，通过 debounce 机制同步到云端
3. 首次登录时，本地和云端数据合并

### 优点
- 支持完全离线使用
- 无需登录即可使用所有功能
- 响应速度快（本地操作）

### 缺点
- 同步逻辑复杂，容易出 bug
- 多端数据可能不一致
- 需要处理冲突解决
- 代码维护成本高
- 用户可能困惑数据存储在哪里

### 适用场景
- 需要完全离线支持的场景
- 对数据一致性要求不高的个人工具

---

## 方案 B: 混合模式（推荐）

### 架构
```
未登录状态:
┌─────────────────┐
│   IndexedDB     │  ← 本地存储，完整功能
│   (本地存储)     │
└─────────────────┘

登录状态:
┌─────────────────┐      ┌─────────────────┐
│   Supabase      │◄────►│   IndexedDB     │
│   (唯一数据源)   │      │   (已清空/禁用)  │
└─────────────────┘      └─────────────────┘
```

### 数据流
1. **未登录**: 数据存储在本地 IndexedDB，完整功能
2. **首次登录**:
   - 如果云端为空 → 上传本地数据到云端 → 清空本地
   - 如果云端有数据 → 询问用户选择（合并/覆盖/保留本地）
3. **登录后**: 所有操作直接读写 Supabase，不再使用本地存储
4. **登出**: 可选择是否下载数据到本地继续使用

### 代码改动点
```typescript
// radarStore 改造
const useRadarStore = create((set, get) => ({
  // 根据登录状态选择存储后端
  async saveProject(project: Project) {
    const user = useAuthStore.getState().user
    if (user) {
      // 登录状态：直接写云端
      await saveCloudProject(project)
    } else {
      // 未登录：写本地
      await db.projects.put(project)
    }
  },

  async loadProjects() {
    const user = useAuthStore.getState().user
    if (user) {
      return await getCloudProjects()
    } else {
      return await db.projects.toArray()
    }
  }
}))
```

### 优点
- 登录后数据一致性好（单一数据源）
- 保留未登录用户的体验
- 架构相对清晰
- 代码改动可控

### 缺点
- 登录后不支持离线使用
- 首次登录的迁移逻辑需要处理
- 需要维护两套存储逻辑（但互斥，不需要同步）

### 实现工作量
- 改造 radarStore：2-3 小时
- 首次登录迁移流程：1-2 小时
- 移除同步相关代码：1 小时
- 测试：2 小时

---

## 方案 C: 纯云端模式

### 架构
```
┌─────────────────┐
│    Supabase     │  ← 唯一数据源
│   (云端存储)     │
└─────────────────┘
        ▲
        │ 必须登录
        │
┌─────────────────┐
│     用户        │
└─────────────────┘
```

### 数据流
1. 应用启动时强制登录
2. 所有数据操作直接读写 Supabase
3. 无本地存储

### 代码改动点
```typescript
// App.tsx 入口
function App() {
  const { user, isLoading } = useAuthStore()

  if (isLoading) return <Loading />
  if (!user) return <LoginPage />  // 强制登录

  return <MainApp />
}

// radarStore 简化
const useRadarStore = create((set, get) => ({
  async saveProject(project: Project) {
    // 只有云端存储
    await saveCloudProject(project)
  },

  async loadProjects() {
    return await getCloudProjects()
  }
}))
```

### 优点
- 架构最简单
- 数据一致性最好
- 代码量最少
- 无需维护同步逻辑
- 多端数据天然一致

### 缺点
- 必须登录才能使用
- 完全不支持离线
- 对网络依赖高
- 用户体验门槛高（需要先注册/登录）

### 实现工作量
- 移除 IndexedDB 相关代码：1 小时
- 改造 radarStore：1-2 小时
- 添加强制登录页面：1 小时
- 移除同步相关代码：1 小时
- 测试：1 小时

---

## 方案 D: 云端主存储 + 本地缓存

### 架构
```
┌─────────────────┐      ┌─────────────────┐
│    Supabase     │─────►│   IndexedDB     │
│   (主存储)       │ 缓存  │   (只读缓存)     │
└─────────────────┘      └─────────────────┘
        ▲
        │ 写操作
        │
┌─────────────────┐
│     用户        │
└─────────────────┘
```

### 数据流
1. 写操作：直接写 Supabase
2. 读操作：优先读本地缓存，缓存失效时从云端拉取
3. 离线时：可以查看缓存的只读数据

### 优点
- 数据一致性好（写操作单一来源）
- 支持离线只读
- 读取性能好

### 缺点
- 需要实现缓存失效策略
- 离线时无法编辑
- 架构复杂度中等
- 仍需要登录

### 实现工作量
- 实现缓存层：3-4 小时
- 缓存失效策略：2 小时
- 测试：2 小时

---

## 方案对比总结

### 一致性 vs 可用性权衡

```
一致性高 ◄─────────────────────────────────────► 可用性高
         │                                      │
    方案 C                                  方案 A
  (纯云端)                                (本地优先)
              │              │
          方案 D          方案 B
        (云端+缓存)     (混合模式)
```

### 推荐方案

**建议选择方案 B（混合模式）**，理由：

1. **平衡性好**: 既保留了未登录用户的体验，又解决了登录后的数据一致性问题
2. **改动可控**: 不需要强制所有用户登录，渐进式改进
3. **用户友好**: 用户可以先试用再决定是否注册
4. **架构清晰**: 登录状态决定存储后端，两套逻辑互斥不需要同步

如果愿意牺牲未登录体验，**方案 C（纯云端）** 是最简单的选择：
- 代码量最少
- 维护成本最低
- 数据一致性最好
- 适合团队协作工具的定位

---

## 实施建议

### 如果选择方案 B（混合模式）

**阶段 1: 改造存储层**
1. 创建统一的存储抽象层 `StorageService`
2. 根据登录状态自动切换后端
3. 移除现有的同步逻辑

**阶段 2: 实现迁移流程**
1. 首次登录时检测本地数据
2. 提供迁移选项 UI
3. 完成迁移后清空本地

**阶段 3: 清理**
1. 移除 syncStore
2. 移除冲突解决相关代码
3. 简化 authStore

### 如果选择方案 C（纯云端）

**一次性改动**
1. 移除 IndexedDB 相关代码
2. 移除 syncStore
3. 改造 radarStore 为纯云端操作
4. 添加登录门槛页面
5. 迁移现有本地数据（提供一次性工具）

---

## 待确认问题

1. **是否保留未登录体验？**
   - 是 → 方案 B
   - 否 → 方案 C

2. **对离线支持的需求程度？**
   - 必须支持 → 方案 A/D
   - 可以不支持 → 方案 B/C

3. **现有用户的本地数据如何处理？**
   - 方案 B: 首次登录时迁移
   - 方案 C: 提供一次性导出工具

4. **对实现工作量的预期？**
   - 最少 → 方案 C
   - 适中 → 方案 B

---

## 下一步

1. 确认选择哪个方案
2. 新开会话进行详细实施
3. 分阶段实现和测试
